computeSales

The program uses files containing receipts as input. The receipts contain the AFM number of each store, the items sold (item, units, price per unit, sum) and the sum of all products. The program must discard invalid receipts and add the valid ones by AFM and for each AFM, sum the products by name.
First we insert the libraries re, decimal and os.path. Their function will be analyzed later. An empty dictionary IDs is initialized which will contain all the data from the valid receipts. Using flags and while loops, the main menu is constantly displayed. The user must indicate a choice for the program to work.
Choice 1: The program asks for a file name. os.path allows to check if the file name given exists. If not, the main menu is brought up, otherwise the file is read using UTF-8 encoding. The amount of lines in the file is stored and a few lists are initialized for later use. Then the program reads all lines and stores the position of the lines that only contain dashes. Lines with only dashes are the limits of each receipt. Afterwards, the validity check begins.
	Validity check: For each AFM, we know its position is written in the line after the dashes. Using re (regex), the format of the line is checked and using strip, the input is cleared of excess spaces. If the AFM line is the wrong format, the receipt is skipped.  Each product is then checked by looping from 0 till (line of last product – line of first product). Last product is the second to last line of the current receipt and the first product is the third line of the current receipt. After excess spaces are removed, each line is split using colon as a delimiter and then once more at the spaces. The last field is the partial sum which will be compared to the receipt total. Using decimal, the number fields are cast to decimals to retain accuracy. If the partial and total sums are not correct at any point, the receipt is skipped. Finally, the total sum is checked for correct formatting and correct amount. 
	Data storing: if the loop reaches this spot, the receipt is valid. The data is saved using nested dictionaries. Dictionaries are used because they allow pairs of information (in this case, afm/products and products are pairs of items/sum) and also allows to search quickly using keywords. Using a list, the entire list would have to be traversed using pointers which takes a long time for lots of data. If the AFM doesn’t exist, a new key is created. The receipt is re-read and to check if the key AFM contains a dictionary with key PRODUCT. If not, it is created using capital letters and is given the value of partial sum. If it does exist, the partial sum is added to the current value and the file is closed.
	Choice 2: A product is given as input. The input is converted to uppercase. A for loop is run on a sorted dictionary so that the AFMs are in increasing order. Using “in”, each AFM is checked if it contains the PRODUCT and it’s printed.
	Choice 3: AFM is input. If it exists in the dictionary, a for loop is run using the sorted nested dictionary of the AFM that was given and it prints the sorted products.
Choice 4: The main loop flag is switched to False and the program terminates.
